falseOld files: 

* topics/applications/applications_of_canopy.dgs

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/canopy_codebase.dgs

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/design_principles_of_canopy.dgs

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/the_diagraph_data_structure.dgs

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/functions_of_the_canopy_library.dgs

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/motivations_for_canopy.dgs

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/the_canopy_project.dgs

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/how_to_use_canopy.dgs

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing






Old files: 

* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing





New and changed files: topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.






Old files: 

* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.





New and changed files: 



Old files: 

* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.





New and changed files: topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline..






Old files: 

* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline..





New and changed files: topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.






Old files: 

* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.





New and changed files: 



Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.


* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: 



Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a Javascript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analayze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.


* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a buisiness requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original buisiness requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are dicussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analyisis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the respository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: 



Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/applications/Applications_of_Canopy.expl

Applications of Canopy: The Canopy library has various applications. There are applications of Canopy in programming. There are applications of Canopy in academia and journalism. There are applications of Canopy in library science.

Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.





New and changed files: topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.





New and changed files: topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Todos/Todos.expl

-


topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

-


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/.DS_Store

   Bud1            �                                                           i c a t i o                                           A p p l i c a t i o n svSrnlong                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             @      �                                        @      �                                          @      �                                          @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   E   �                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DSDB                                 `      �                                               @      �                                          @      �                                          @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          




New and changed files: 



Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]






Old files: 

* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up. [[a]]


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase. [[a]]

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1


// Error: Reference [[a]] in [The Canopy project, The Canopy project] matches no global, local, or import reference.
/Users/azriel/docs/topics/Canopy/The_Canopy_project.expl:1





New and changed files: topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: 



Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -





New and changed files: topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -

k






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -

k





New and changed files: 



Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -

k


* topics/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -

k





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs


topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files


topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error


topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph.





New and changed files: topics/Diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph.


Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/If_I_make_a_provisional_subcategory_I_can_add_a_note_to_the_parent_reminding_that_it_exists_and_should_receive_a_forereference_at_some_point_–_ie_AT.expl

If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.


topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/Canopy/Todos/Todos.expl

- Identify over-large category files to prompt organic break up.
- Custom bulk file sorter that puts the default category first
- Don't put asterisks for category files
- Put some visual marker for dead-end paragraphs
- Maybe the default topic dotfile should be a regular file
- Should changes to the expl files change the bulk file? Or would that be disorienting?
- Maybe csv mode should be in addition to bulk, and it should produce and watch both files
- Am I properly desluggifying category names?
- Make the default github actions create a bulk file and then on commit check if the bulk file was edited
- Maybe dont delete the old build until you are sure the new one will be successful, in case there is a syntax error
- Make a backup folder and write every bulk file with a timestamp
- Don't overwrite existing bulk file, just error
- Have build script check that default topic corresponds to a topic file
- Maybe default topic should be not in a dotfile
- Make all serious errors red background
- Make new file character something other than * because people might want to start notes like that
- Have deletions use red background for action and red text for filepath?
- In sync mode changes to one bulk file should rewrite the other
- Maybe every file _should_ get its own header in the bulk file? Rather than eg * ?
- Test bulk file where first file for category omits * but is topic
- If I move a top-level category, does it recursively move all the children?
- Null link selection?





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.





New and changed files: topics/Diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/diagraph/Does_a_topic_paragraph_assume_knowledge_of_the_children_of_earlier_local_references?.expl

Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.


topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)


topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)


topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


topics/Inbox/Inbox.expl

Spaced reptition by email






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Inbox/Inbox.expl

Spaced reptition by email





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Inbox/Inbox.expl

Spaced reptition by email


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


topics/Desiderata/Desiderata.expl

Spaced repetition heat map


topics/Inbox/Inbox.expl

Spaced repetition by email.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [why Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [why Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [why Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [why Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps], and [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works], and [how Canopy is used].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems that Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also imagine [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy was designed to solve]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also the specific [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps] in general, and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level, and [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level and [how Canopy was designed]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different industries and use-cases. Those interested can inquire into [how Canopy works] on a technical level and [how Canopy was designed]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and [how Canopy was designed]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and [how Canopy was designed]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, [the applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, [the applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, [the applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand [the problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand [the design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make use of the project can read into [how Canopy is used] practically speaking.

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walkthrough].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walkthrough].

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the mishna on kedushin XY be such and such" may prerequire the mishna, but not everything between the mishna and that question, indeed, there isn't really anything between the mishna and that question, there is disamiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the mishna on kedushin XY be such and such" may prerequire the mishna, but not everything between the mishna and that question, indeed, there isn't really anything between the mishna and that question, there is disamiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disamiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disamiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessable by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.

All of history, and for each point, what artifacts we have from that period.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.

All of history, and for each point, what artifacts we have from that period.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.

All of history, and for each point, what artifacts we have from that period.

Is diagraph a dependency graph? It is, provided that you recognize that half the links represent prerequisites and half the link represent the inverse relationship, compositions.






Old files: 

* topics/Applications/Applications.expl

- Applications of Canopy in programming: The original author of a codebase is often more comfortable maintaining it than are later team members. Canopy can help original authors organize the information they know, such as which parts of the code power which features, where certain decisions are made, and what the original motivations for various design choices were. One could begin at a business requirement, and look at the features that satisfy it, the design decisions made for that feature, and the code that implements it, or one could begin with a line of code and work up, seeing what it does, and why, all the way to the original business requirement.

- The train of thought leading to each test case, from a description of the system under test.

- Applications of Canopy in academia and journalism: Some of the same subjects that are discussed in popularly are also studied in academic institutions. If explanations that were produced in academia were organized differently, it might be more easy for journalists and popular commentators to connect stories of the day to long-term historical or economic analysis, allowing readers who begin at a story to drill into its larger themes, and for students of theoretical ideas to find practical examples of how they play out in the world.

- Canopy can be used as your school notebook for a class, and your goal in reviewing your notes is to come up with an explanation that subsumes all the points made in class, why was each necessary.

- Applications of Canopy in library science: For any set of books, one can imagine a librarian who has read all of them, and could answer questions like "what author addresses this or that point", and without taking sides, that librarian could through quotations put one author in conversation with another, and could list for you all the arguments made in the literature for one position or the other, and the responses, in neutral terms, exerting judgement only in the potential meaning of terms in ordinary language. Therefore, for any set of static resources and a shared language, there exists a set of valid "library diagraphs", which present the indexing of the different parts of those resources by what questions they address and what answers they give, and it might be desirable to produce such diagraphs for popular consumption.


* topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


* topics/Canopy/The_Canopy_project.expl

The Canopy project: This is the documentation of the Canopy.js project. First, it is useful to understand the [ problems Canopy solves]. Then, we can discuss [how Canopy helps], and also specifically, the [ applications of Canopy] in different use-cases. Those interested can inquire into [how Canopy works] on a technical level and understand the [ design of Canopy]. Those wishing to make their own project with Canopy can read about [how Canopy is used] practically speaking. Anyone unfamiliar with the user interface can do a short [walk through]. (Try using the arrow keys.)

Canopy is a JavaScript library for creating and browsing the diagraph data structure. There are functions of the Canopy library. There are motivations for Canopy. There are design principles of Canopy. There are applications of Canopy. There is a way how to use Canopy. There is a Canopy codebase.

- Canopy has features/desiderata? There need to be clause links, so that you can zoom in on a description white paper archive notes
- English as programming language
- Use question topic names.


* topics/Patterns/Patterns.expl

The way that you sometimes zoom in and sometimes zoom out to analyze a thing

A course is like a diagraph in that everything you mention has to be connected to some previous thing, subsuming even the whole discipline.

We can add invariants like "how do you know" to every point.

Maybe there is a habit of only referencing entities even in prose if they have been imported via link in that paragraph or a direct ancestor.

Overlapping entities like a perek with sugya subtopics and the sugyas as topics, and the differences in how the same information is covered in those two contexts.


* topics/code/Canopy_codebase.expl

Canopy codebase: The Canopy codebase contains the Canopy front-end library, the Canopy parser library, and the Canopy command-line interface.

Canopy front-end library: The Canopy codebase contains a front-end library. The front-end code can be found in the repository. The front-end library consumes JSON produced by the parser library which is served by a Canopy server. The code base implements the Canopy project.

The front-end code can be found in the repository: The front-end code can be found in the repository under the `src/client` path.

Canopy parser library: The Canopy codebase contains the backend code for the parser that Canopy uses to convert diagraph script into the JSON that is consumed by the front-end library.

Canopy command-line interface: Canopy has a command-line interface that you can use to set up a Canopy project, convert dgs files into JSON, and run a Canopy server!


* topics/design/Design_principles_of_Canopy.expl

Design principles of Canopy: Canopy is designed to mimic the interface of human explanation. The Canopy parser is intended to recognize the same patterns in text as does a human listener.

Mimic the interface of human explanation: Canopy is intended to present the same options to the reader as does a human explainer. The same way that an expert can summarize a domain and then be asked follow up questions, Canopy presents a small amount of information that contains within it follow-up queries that are supported.

The same patterns in text as does a human listener: When a later paragraph references an earlier one, it shouldn't need to be identified with a hypertext reference, because a human reader wouldn't need hypertext to identify the reference as a reference. It must be that the reader recognizes something in the later paragraph they saw in the earlier one, and on this basis recognizes the reference. Canopy is intended to make the same recognition based on the same information.

- Links that reify ordinary language reference - synchronized with no way for links to change from linguistic reference.


* topics/diagraph/The_diagraph_data_structure.expl

The diagraph data structure: There is a definition of diagraph. There are things that make good diagraph. There are different methods of making diagraph. There are implementations of the diagraph data structure.

Definition of diagraph: Diagraph is a graph data structure. Traversals of diagraph are valid prose explanations. A diagraph is composed of a global namespace of topics. Each topic contains a local namespace of subtopic names. One subtopic of the topic matches the topic.

- For each line of the definition, give an example as a local reference.

Good diagraph: Certain qualities make diagraph good.

Methods of making diagraph: There are different methods for making diagraph. You can use the canopy bulk mode for example.

Canopy bulk mode: The canopy bulk mode is a CLI tool for making diagraph.

- Library diagraph and the motivation ie the need for uncontroversial summaries of what views exist without trust for the summarizer.

Implementations of the diagraph data structure: Of which, the Canopy project is one.


* topics/functions/Functions_of_the_Canopy_library.expl

Functions of the Canopy library: There are certain functions the Canopy library performs, like run a Canopy server.

Canopy server: A Canopy server is a server that serves and supports the Canopy.js library. The Canopy server can be a static assets server or a node.js script. The server delivers the Canopy.js library on the first request, and then handles subsequent requests from the browser for JSON data files. The Canopy server is necessary to view an example of the Canopy project.

Diagraph script: Diagraph script is a natural language text format that Canopy uses to construct a Canopy website.


* topics/motivations/Motivations_for_Canopy.expl

Motivations for Canopy: There are problems Canopy is intended to solve. There are interactions Canopy is designed to support. There are reasons why a solution like Canopy should be possible.

- The idea that experts have a massively redundant graph where every topic relates to every other topic.

Problems Canopy is intended to solve: There are certain inefficiencies in the current creation and consumption of explanation that motivate the creation and use of Canopy.

- Canopy can be compared to other solutions to those same problems, wikis, annotation, semantic web, etc.

Interactions Canopy is designed to support: There are certain desirable ways of interacting with explanation that Canopy supports.


Reasons why a solution like Canopy should be possible: Here they are.

THe fact that infinite tree storage has only existed for a bit, and binary search being the most efficient way to look things up.


* topics/usage/How_to_use_Canopy.expl

How to use Canopy: There are instructions for how to produce diagraph with Canopy, and how to use a Canopy website.

How to use a Canopy website: Here is how.

How to produce diagraph with Canopy: Canopy turns a directory of diagraph script files into -


* topics/Benefits/Benefits.expl

- Giving information in stages creates earlier images that forereference later ones, so that the information is recallable.


* topics/Production/Production.expl

- If I make a provisional subcategory I can add a note to the parent reminding that it exists and should receive a forereference at some point – ie AT: how do I get visibility into nearby categories that need to be subsumed?

- Maybe when all the children of a point cohere into 4 subcategories I descend.

- Most disambiguation is probably all global references, and maybe even new categories at every level.

I didn't see subcategories could proceed


* topics/Comparisons/Comparisons.expl

Compare diagraph to programming, eg scope, call stack, functional paradigms versus imperative, etc.


* topics/Fragmentation/Fragmentation.expl

A source of fragmentation is that experts use generic predication rather than explicit forereference because for _them_ it _is_ a reliable reference.


* topics/Desiderata/Desiderata.expl

Spaced repetition heat map


* topics/Inbox/Inbox.expl

Spaced repetition by email.

Large content with small bites

Secondary indexes on things eg suffixes and prefixes

That diagraph doesn't overexplain things to people but only what is necessary

Conceptual taxonomy – the best way we have of communicating what we want to convey is NPs, and sometimes just category names.

Diagraph might be easier to review because you can recursively dive to the component you need to understand, and then cache that concept by name, and so each sweep you do, you need to have less and less be explained because you retain the pieces better, until the name of the concept itself reliably hits a compiled sense image.

Maybe subcategories are often temporary, and the persistent category tree is much less deep, maybe even only 2 levels deep.

What you were looking for is "part" of the picture of the solution, ie an explanation of a tool includes an explanation of the problem, because a tool can only be understood in that light.

Diagraph makes it clearer whether something is informational or if it is style and voice also.

It is hard to see the edge of what is known to motivate additions/research

There is no path from the wikipedia page on panda bears to everything about panda bears

The idea that eg wikipedia is still a "document" and that we should be representing the units that comprise documents.

Explain the design goals of Canopy ie interface of the expert, and how that boils down to these specific design decisions.

It isn't organic to sit down and learn eg history, grammar, except in the context of a given example, and so diagraph makes these things accessible by putting them "on" the example, and when the person has seen the concept shed light on enough examples, they may be motivated to learn it on its own from the ground up.

Big topics are an example of consolidation, that experts do have flexibly access to parts of an explanation, but that doesn't mean the explanation is stored in many small pieces. It might be that to maintain consistency, a large tree is stored, and redundant topics point at subtopics.

What is the difference between the prerequisance we model as siblings versus the prerequisance we model as children?

Writing a diagraph produces less perfectionism because you can add as you go.

The test of whether something is a subtopic or a topic isn't whether it is a conversation starter, because you can start a conversation about something but nevertheless be assuming that the other person knows about some preamble.

We need things like computer science to be explained with a human side, what was the design goal, why was this feature created, etc.

I think that you shouldn't say eg there are [x] (which are helpful for abc), ie, if a link is ambiguous, explain in the child, not in the parent, such that the parent becomes the post-explanation phrasing.

Merger of academia and journalism

Reading large stories instead of many small ones.

A question can be a topic, and the key to avoiding imperative explanations is that not everything is a prerequisite, eg if the question says "how can the X on page XY be such and such" may prerequire X, but not everything between X and that question, indeed, there isn't really anything between X and that question, there is disambiguation down, but the question is connected up in one step, and this is probably a pattern, subordinate topic trees.

A topic can require the context of another and yet be an independent topic, because subtopics are for things that syntactically require the parent like a nose, whereas you can always zoom out further.

The idea that a certain utterance may be at a point in a series of versions and modifications that have to be reconstructed by the listener. Sometimes there are hints eg "time and space are merely subjective", but sometimes it is eg "lets have mint, no lets have chamomile, no after all lets have mint", ie the conclusion is in a certain context.

All of history, and for each point, what artifacts we have from that period.

Is diagraph a dependency graph? It is, provided that you recognize that half the links represent prerequisites and half the link represent the inverse relationship, compositions.


* topics/diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.





New and changed files: topics/Diagraph/Diagraph.expl

- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.


- Does a topic paragraph assume knowledge of the children of earlier local references? The NP of the local reference is the only thing that survives the previous descent and so that NP is affected by all its children semantically, but one is not responsible in the parent paragraph for remembering all the named entities from the prior children, only those terms that are named explicitly in that paragraph are available in the paragraph. And we can say just like pure functions don't have side effects, good references only import the NP referenced, which carries everything you need to know.
- In a big function body, the later expressions can use the earlier variables, but that doesn't mean that later function calls can use those variables, nor that the local variables of earlier function calls are available in the top-level.

- Only some of the links in a paragraph are prerequisites, and it depends on where the token occurs in the sentence. "Given [X]" is a prerequisite, but "and a related concept is [X]" isn't. So diagraph is a dependency graph perhaps, but it isn't so simple as to say every link is a dependency, it depends on context.
- But it would be a sensible convention for people to follow that prerequisite links would be the first ones, the specifications at the end, so that a DFS is possible without reading everything. (Though whether parentheticals should be at the start or intentionally at the end I don't know.)

How diagraph makes things quicker to review, because each level becomes a rote image usable by the upper layer.



